<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>grahamscandelaunay API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grahamscandelaunay</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import point
from collections import deque
import numpy
numpy.seterr(all=&#39;raise&#39;)

class HalfEdge:
    &#34;&#34;&#34;This class represents a HalfEdge in a HalfEdge data structure.&#34;&#34;&#34;

    def __init__(self, point, link = None, prev = None, twin = None):
        &#34;&#34;&#34;
        Parameters
        -----------
        point : Point
            The start point for the half edge

        link : HalfEdge
            The next HalfEdge that this HalfEdge points to
        
        prev : HalfEdge
            the previous HalfEdge that links to this HalfEdge
        
        twin : HalfEdge
            The twin HalfEdge of this HalfEdge
        &#34;&#34;&#34;
        self.point = point
        self.link = link
        self.prev = prev
        self.twin = twin

class GrahamScanDelaunay:
    &#34;&#34;&#34;This class represents an instance of the Graham Scan Based Incremenatal Delaunay algorithm.&#34;&#34;&#34;
    def __init__(self, V):
        &#34;&#34;&#34;
        The __init__ method will sort the points to be in ccw order. It will also create the stack, queue,
        and a list of edges used in the incremental algorithm.

        Parameters
        -----------
        V : List
            The List of Point objects for the incremental delaunay algorithm to run on.

        Attributes
        --------------
        V : List
            The list of Point objects for the incremental delaunay algorithm to run on.

        stack : Deque
            The stack maintains the edges on the convex hull.

        q : Deque
            q is a queue that maintains the edges that need to be checked to see if they are delaunay.

        edges : Deque
            This is a list of all the edges that are in the triangulation.

        flips : Integer
            Maintains a count of the number of edges that have been fliped to be locally delaunay
        &#34;&#34;&#34;
        # Assume General Position: No 3 points in V are collinear
        # and no 4 points in V are cocircular

        # Sort the points
        self.V = self._sort_points(V)
        
        # Initializing Data Structures
        self.stack = deque() # Convex Hull Half Edge Stack
        self.q = deque() # Delaunay Half Edge Queue
        self.edges = deque() # List of All Edges
        self.flips = 0

    # Yields the current iteration, the sorted list of points, and the edges in the triangulation
    def run(self):
        &#34;&#34;&#34; This method is used to run the graham scan based incremental delaunay algorithm.

        It yeilds the state of the algorithm at each iteration to the visualization.
        This method starts out by first creating a base triangle of the first 3 points from the list of points
        sorted in CCW order. 

        It then incrementally adds another point to the triangularization. It does this by running the graham
        scan algorithm to get the next edge of the convex hull, then adds the edge from the initial point to the 
        current point, and then checks to see if the edge added is locally delaunay. If it is delaunay, we proceed
        to the next point. If it is not delaunay, we flip the edge.
        &#34;&#34;&#34;

        n=len(self.V)

        # Construct base triangle
        base = [self.V[0], self.V[1], self.V[2]]

        # Convert triangle into half-edges
        outside = [HalfEdge(p) for p in base]
        inside = [HalfEdge(p) for p in base]
        for i in range(3):
            outside[i - 1].twin = inside[i]
            inside[i].twin = outside[i - 1]

            outside[i - 1].link = outside[i]
            outside[i].prev = outside[i - 1]

            inside[i].link = inside[i - 1]
            inside[i - 1].prev = inside[i]
            self.stack.append(outside[i])
            self.edges.append(outside[i])

        # Return base triangle for visualization
        yield self._get_vis_data()

        # Incrementally add to the triangulation
        for i in range(3, n):
            yield from self._incrementhull(self.V[i])
            yield self._get_vis_data(self.V[i], True) # Data to visualize after convex hull
            # Check if the new edges need to be flipped
            while len(self.q) &gt; 0:
                print(&#34;Printing self.q&#34;)
                for h in self.q:
                    print(h.point)
                print(&#34;checking isdelaunay()&#34;)
                self._isdelaunay(self.q.popleft())
                yield self._get_vis_data(self.V[i], True) # Data to visualize after delaunay check

    # Returns a list of halfedges for visualization purposes
    def _getedges(self):
        return iter(self.edges)

    # Returns the current edge being checked for visualization purposes
    # If the queue is empty, return None
    def _currentedge(self):
        return self.q[0] if len(self.q) &gt; 0 else None

    # Given the index of the current point, returns a list for visualization purposes
    def _get_vis_data(self, currentpt = None, delaunay_step = False):
        cc = None
        if delaunay_step and len(self.q) &gt; 0 and not self._isOutside(self.q[0]) :
            cc = self._getCircumcenter(self.q[0])
        return [currentpt, self._getedges(), self.q, self.stack, cc, delaunay_step, self.flips]

    # returns the circumcenter of the triangle the halfedge is in
    def _getCircumcenter(self, h):
        print(&#34;Checking cc(&#34;, h.point, h.prev.point, h.link.point, &#34;) = &#34;, point.circumcenter(h.point, h.prev.point, h.link.point))
        return point.circumcenter(h.point, h.prev.point, h.link.point)

    # returns whether the edge is on the convex hull
    def _isOutside(self, h):
        return h in self.stack or h.twin in self.stack


    # Connects an edge from a.point to b.point
    # Assumes a and b are the outside halfedges
    # During the convex hull process
    def _addedge(self, a, b):
        c = HalfEdge(a.point, b, a.prev)
        d = HalfEdge(b.point, a, b.prev, c)
        c.twin = d
        a.prev.link = c
        b.prev.link = d
        a.prev = d
        b.prev = c
        # Push new edge into the Delaunay Edge Queue
        self.q.append(c)
        self.edges.append(c)
        return c

    # Connects an edge from a.point to p
    # a is the outside halfedge and p is a point
    # Only used for the convex hull
    def _addleaf(self, a, p):
        h = HalfEdge(p, a)
        t = HalfEdge(a.point, h, a.prev, h)
        h.prev = t
        h.twin = t
        a.prev.link = t
        a.prev = h
        # Push new edge into the Delaunay Edge Queue
        self.q.append(h)
        self.edges.append(t)
        return h
    
    # Use the convex hull algorithm to add edges to the triangulation
    def _incrementhull(self, p):
        # Connect the top point of the stack to the new point
        self._addleaf(self.stack[-1], p)
        yield self._get_vis_data(p)
        h = self.q[-1] # Halfedge from p
        # Run graham scan to see if backtracking is needed
        while (point.orient(self.stack[-2].point, self.stack[-1].point, p) != 1):
            self.q.append(self.stack.pop())
            self._addedge(self.stack[-1], h)
            yield self._get_vis_data(p)
        # Connect the new point to the first point
        self._addedge(h, self.stack[0])
        yield self._get_vis_data(p)
        # Add the convex hull outside halfedge to the stack
        self.q.append(h.link)
        h2 = self.stack.pop()
        if h2 not in self.q and h.twin not in self.q:
            self.q.append(h2)
        self.stack.append(h.prev.twin.prev)
        self.stack.append(h.prev.twin)
        
    
    # check if edge is locally delaunay; returns false if the edge is flipped
    def _isdelaunay(self, h):
        # Outside edge, do not flip
        if self._isOutside(h):
            print(h.point, &#39; is an outside edge, no need to do incircle test&#39;)
            return
        # if not locally delaunay, flip the edge
        print(&#34;Checking incircle(&#34;, h.point, h.prev.point, h.link.point, h.twin.prev.point, &#34;)&#34;)
        print(&#34;Incircle returns: &#34;, point.incircle(h.point, h.prev.point, h.link.point, h.twin.prev.point))
        if point.incircle(h.point, h.prev.point, h.link.point, h.twin.prev.point) &gt; 0:
            print(&#34;Flipping Edge&#34;)
            self._flipedge(h)
            self.flips += 1
            return False
        return True

    # Flip the current edge
    def _flipedge(self, h):
        # Link the quad toegether
        h.prev.link = h.twin.link
        h.twin.prev.link = h.link
        h.link.prev = h.twin.prev
        h.twin.link.prev = h.prev
        # Flip the edge
        h.link = h.prev
        h.twin.link = h.twin.prev
        h.prev = h.twin.link.prev
        h.twin.prev = h.link.prev
        # Link the quad back to the edge
        h.link.prev = h
        h.twin.link.prev = h.twin
        h.prev.link = h
        h.twin.prev.link = h.twin
        h.point = h.twin.link.point
        h.twin.point = h.link.point
        # Push the neighboring edges into the Delaunay Queue
        self.q.append(h.link)
        self.q.append(h.prev)
        self.q.append(h.twin.link)
        self.q.append(h.twin.prev)
        return
    
    # Sort the points such that the first point of the list
    # is the bottomleftmost, and the remaining points
    # are sorted in ascending order of their slope
    # with respect to the first point
    def _sort_points(self, V):
        leftmost = min(V, key = lambda p: p)
        _V = sorted(V, key = lambda p: point.slope(leftmost, p))
        return _V
        # n = len(V)
        # # Sort by x-coordinates to get the first point
        # _V = sorted(V)
        
        # # Map each point to the slope relative to the bottomleftmost point
        # pairs = [(_V[0], float(&#39;-inf&#39;))]
        # for i in range(1,n):
        #     pairs.append((_V[i], point.slope(_V[0], _V[i])))

        # pairs = pairs[0:1] + sorted(pairs[1:], key=lambda p: p[1]) # Sort by slope

        # # Return the list of points
        # output = []
        # for p in pairs:
        #     output.append(p[0])
        # return output</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grahamscandelaunay.GrahamScanDelaunay"><code class="flex name class">
<span>class <span class="ident">GrahamScanDelaunay</span></span>
<span>(</span><span>V)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents an instance of the Graham Scan Based Incremenatal Delaunay algorithm.</p>
<p>The <strong>init</strong> method will sort the points to be in ccw order. It will also create the stack, queue,
and a list of edges used in the incremental algorithm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>List</code></dt>
<dd>The List of Point objects for the incremental delaunay algorithm to run on.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>List</code></dt>
<dd>The list of Point objects for the incremental delaunay algorithm to run on.</dd>
<dt><strong><code>stack</code></strong> :&ensp;<code>Deque</code></dt>
<dd>The stack maintains the edges on the convex hull.</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>Deque</code></dt>
<dd>q is a queue that maintains the edges that need to be checked to see if they are delaunay.</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>Deque</code></dt>
<dd>This is a list of all the edges that are in the triangulation.</dd>
<dt><strong><code>flips</code></strong> :&ensp;<code>Integer</code></dt>
<dd>Maintains a count of the number of edges that have been fliped to be locally delaunay</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GrahamScanDelaunay:
    &#34;&#34;&#34;This class represents an instance of the Graham Scan Based Incremenatal Delaunay algorithm.&#34;&#34;&#34;
    def __init__(self, V):
        &#34;&#34;&#34;
        The __init__ method will sort the points to be in ccw order. It will also create the stack, queue,
        and a list of edges used in the incremental algorithm.

        Parameters
        -----------
        V : List
            The List of Point objects for the incremental delaunay algorithm to run on.

        Attributes
        --------------
        V : List
            The list of Point objects for the incremental delaunay algorithm to run on.

        stack : Deque
            The stack maintains the edges on the convex hull.

        q : Deque
            q is a queue that maintains the edges that need to be checked to see if they are delaunay.

        edges : Deque
            This is a list of all the edges that are in the triangulation.

        flips : Integer
            Maintains a count of the number of edges that have been fliped to be locally delaunay
        &#34;&#34;&#34;
        # Assume General Position: No 3 points in V are collinear
        # and no 4 points in V are cocircular

        # Sort the points
        self.V = self._sort_points(V)
        
        # Initializing Data Structures
        self.stack = deque() # Convex Hull Half Edge Stack
        self.q = deque() # Delaunay Half Edge Queue
        self.edges = deque() # List of All Edges
        self.flips = 0

    # Yields the current iteration, the sorted list of points, and the edges in the triangulation
    def run(self):
        &#34;&#34;&#34; This method is used to run the graham scan based incremental delaunay algorithm.

        It yeilds the state of the algorithm at each iteration to the visualization.
        This method starts out by first creating a base triangle of the first 3 points from the list of points
        sorted in CCW order. 

        It then incrementally adds another point to the triangularization. It does this by running the graham
        scan algorithm to get the next edge of the convex hull, then adds the edge from the initial point to the 
        current point, and then checks to see if the edge added is locally delaunay. If it is delaunay, we proceed
        to the next point. If it is not delaunay, we flip the edge.
        &#34;&#34;&#34;

        n=len(self.V)

        # Construct base triangle
        base = [self.V[0], self.V[1], self.V[2]]

        # Convert triangle into half-edges
        outside = [HalfEdge(p) for p in base]
        inside = [HalfEdge(p) for p in base]
        for i in range(3):
            outside[i - 1].twin = inside[i]
            inside[i].twin = outside[i - 1]

            outside[i - 1].link = outside[i]
            outside[i].prev = outside[i - 1]

            inside[i].link = inside[i - 1]
            inside[i - 1].prev = inside[i]
            self.stack.append(outside[i])
            self.edges.append(outside[i])

        # Return base triangle for visualization
        yield self._get_vis_data()

        # Incrementally add to the triangulation
        for i in range(3, n):
            yield from self._incrementhull(self.V[i])
            yield self._get_vis_data(self.V[i], True) # Data to visualize after convex hull
            # Check if the new edges need to be flipped
            while len(self.q) &gt; 0:
                print(&#34;Printing self.q&#34;)
                for h in self.q:
                    print(h.point)
                print(&#34;checking isdelaunay()&#34;)
                self._isdelaunay(self.q.popleft())
                yield self._get_vis_data(self.V[i], True) # Data to visualize after delaunay check

    # Returns a list of halfedges for visualization purposes
    def _getedges(self):
        return iter(self.edges)

    # Returns the current edge being checked for visualization purposes
    # If the queue is empty, return None
    def _currentedge(self):
        return self.q[0] if len(self.q) &gt; 0 else None

    # Given the index of the current point, returns a list for visualization purposes
    def _get_vis_data(self, currentpt = None, delaunay_step = False):
        cc = None
        if delaunay_step and len(self.q) &gt; 0 and not self._isOutside(self.q[0]) :
            cc = self._getCircumcenter(self.q[0])
        return [currentpt, self._getedges(), self.q, self.stack, cc, delaunay_step, self.flips]

    # returns the circumcenter of the triangle the halfedge is in
    def _getCircumcenter(self, h):
        print(&#34;Checking cc(&#34;, h.point, h.prev.point, h.link.point, &#34;) = &#34;, point.circumcenter(h.point, h.prev.point, h.link.point))
        return point.circumcenter(h.point, h.prev.point, h.link.point)

    # returns whether the edge is on the convex hull
    def _isOutside(self, h):
        return h in self.stack or h.twin in self.stack


    # Connects an edge from a.point to b.point
    # Assumes a and b are the outside halfedges
    # During the convex hull process
    def _addedge(self, a, b):
        c = HalfEdge(a.point, b, a.prev)
        d = HalfEdge(b.point, a, b.prev, c)
        c.twin = d
        a.prev.link = c
        b.prev.link = d
        a.prev = d
        b.prev = c
        # Push new edge into the Delaunay Edge Queue
        self.q.append(c)
        self.edges.append(c)
        return c

    # Connects an edge from a.point to p
    # a is the outside halfedge and p is a point
    # Only used for the convex hull
    def _addleaf(self, a, p):
        h = HalfEdge(p, a)
        t = HalfEdge(a.point, h, a.prev, h)
        h.prev = t
        h.twin = t
        a.prev.link = t
        a.prev = h
        # Push new edge into the Delaunay Edge Queue
        self.q.append(h)
        self.edges.append(t)
        return h
    
    # Use the convex hull algorithm to add edges to the triangulation
    def _incrementhull(self, p):
        # Connect the top point of the stack to the new point
        self._addleaf(self.stack[-1], p)
        yield self._get_vis_data(p)
        h = self.q[-1] # Halfedge from p
        # Run graham scan to see if backtracking is needed
        while (point.orient(self.stack[-2].point, self.stack[-1].point, p) != 1):
            self.q.append(self.stack.pop())
            self._addedge(self.stack[-1], h)
            yield self._get_vis_data(p)
        # Connect the new point to the first point
        self._addedge(h, self.stack[0])
        yield self._get_vis_data(p)
        # Add the convex hull outside halfedge to the stack
        self.q.append(h.link)
        h2 = self.stack.pop()
        if h2 not in self.q and h.twin not in self.q:
            self.q.append(h2)
        self.stack.append(h.prev.twin.prev)
        self.stack.append(h.prev.twin)
        
    
    # check if edge is locally delaunay; returns false if the edge is flipped
    def _isdelaunay(self, h):
        # Outside edge, do not flip
        if self._isOutside(h):
            print(h.point, &#39; is an outside edge, no need to do incircle test&#39;)
            return
        # if not locally delaunay, flip the edge
        print(&#34;Checking incircle(&#34;, h.point, h.prev.point, h.link.point, h.twin.prev.point, &#34;)&#34;)
        print(&#34;Incircle returns: &#34;, point.incircle(h.point, h.prev.point, h.link.point, h.twin.prev.point))
        if point.incircle(h.point, h.prev.point, h.link.point, h.twin.prev.point) &gt; 0:
            print(&#34;Flipping Edge&#34;)
            self._flipedge(h)
            self.flips += 1
            return False
        return True

    # Flip the current edge
    def _flipedge(self, h):
        # Link the quad toegether
        h.prev.link = h.twin.link
        h.twin.prev.link = h.link
        h.link.prev = h.twin.prev
        h.twin.link.prev = h.prev
        # Flip the edge
        h.link = h.prev
        h.twin.link = h.twin.prev
        h.prev = h.twin.link.prev
        h.twin.prev = h.link.prev
        # Link the quad back to the edge
        h.link.prev = h
        h.twin.link.prev = h.twin
        h.prev.link = h
        h.twin.prev.link = h.twin
        h.point = h.twin.link.point
        h.twin.point = h.link.point
        # Push the neighboring edges into the Delaunay Queue
        self.q.append(h.link)
        self.q.append(h.prev)
        self.q.append(h.twin.link)
        self.q.append(h.twin.prev)
        return
    
    # Sort the points such that the first point of the list
    # is the bottomleftmost, and the remaining points
    # are sorted in ascending order of their slope
    # with respect to the first point
    def _sort_points(self, V):
        leftmost = min(V, key = lambda p: p)
        _V = sorted(V, key = lambda p: point.slope(leftmost, p))
        return _V</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grahamscandelaunay.GrahamScanDelaunay.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used to run the graham scan based incremental delaunay algorithm.</p>
<p>It yeilds the state of the algorithm at each iteration to the visualization.
This method starts out by first creating a base triangle of the first 3 points from the list of points
sorted in CCW order. </p>
<p>It then incrementally adds another point to the triangularization. It does this by running the graham
scan algorithm to get the next edge of the convex hull, then adds the edge from the initial point to the
current point, and then checks to see if the edge added is locally delaunay. If it is delaunay, we proceed
to the next point. If it is not delaunay, we flip the edge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34; This method is used to run the graham scan based incremental delaunay algorithm.

    It yeilds the state of the algorithm at each iteration to the visualization.
    This method starts out by first creating a base triangle of the first 3 points from the list of points
    sorted in CCW order. 

    It then incrementally adds another point to the triangularization. It does this by running the graham
    scan algorithm to get the next edge of the convex hull, then adds the edge from the initial point to the 
    current point, and then checks to see if the edge added is locally delaunay. If it is delaunay, we proceed
    to the next point. If it is not delaunay, we flip the edge.
    &#34;&#34;&#34;

    n=len(self.V)

    # Construct base triangle
    base = [self.V[0], self.V[1], self.V[2]]

    # Convert triangle into half-edges
    outside = [HalfEdge(p) for p in base]
    inside = [HalfEdge(p) for p in base]
    for i in range(3):
        outside[i - 1].twin = inside[i]
        inside[i].twin = outside[i - 1]

        outside[i - 1].link = outside[i]
        outside[i].prev = outside[i - 1]

        inside[i].link = inside[i - 1]
        inside[i - 1].prev = inside[i]
        self.stack.append(outside[i])
        self.edges.append(outside[i])

    # Return base triangle for visualization
    yield self._get_vis_data()

    # Incrementally add to the triangulation
    for i in range(3, n):
        yield from self._incrementhull(self.V[i])
        yield self._get_vis_data(self.V[i], True) # Data to visualize after convex hull
        # Check if the new edges need to be flipped
        while len(self.q) &gt; 0:
            print(&#34;Printing self.q&#34;)
            for h in self.q:
                print(h.point)
            print(&#34;checking isdelaunay()&#34;)
            self._isdelaunay(self.q.popleft())
            yield self._get_vis_data(self.V[i], True) # Data to visualize after delaunay check</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grahamscandelaunay.HalfEdge"><code class="flex name class">
<span>class <span class="ident">HalfEdge</span></span>
<span>(</span><span>point, link=None, prev=None, twin=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a HalfEdge in a HalfEdge data structure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>Point</code></dt>
<dd>The start point for the half edge</dd>
<dt><strong><code>link</code></strong> :&ensp;<code><a title="grahamscandelaunay.HalfEdge" href="#grahamscandelaunay.HalfEdge">HalfEdge</a></code></dt>
<dd>The next HalfEdge that this HalfEdge points to</dd>
<dt><strong><code>prev</code></strong> :&ensp;<code><a title="grahamscandelaunay.HalfEdge" href="#grahamscandelaunay.HalfEdge">HalfEdge</a></code></dt>
<dd>the previous HalfEdge that links to this HalfEdge</dd>
<dt><strong><code>twin</code></strong> :&ensp;<code><a title="grahamscandelaunay.HalfEdge" href="#grahamscandelaunay.HalfEdge">HalfEdge</a></code></dt>
<dd>The twin HalfEdge of this HalfEdge</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HalfEdge:
    &#34;&#34;&#34;This class represents a HalfEdge in a HalfEdge data structure.&#34;&#34;&#34;

    def __init__(self, point, link = None, prev = None, twin = None):
        &#34;&#34;&#34;
        Parameters
        -----------
        point : Point
            The start point for the half edge

        link : HalfEdge
            The next HalfEdge that this HalfEdge points to
        
        prev : HalfEdge
            the previous HalfEdge that links to this HalfEdge
        
        twin : HalfEdge
            The twin HalfEdge of this HalfEdge
        &#34;&#34;&#34;
        self.point = point
        self.link = link
        self.prev = prev
        self.twin = twin</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grahamscandelaunay.GrahamScanDelaunay" href="#grahamscandelaunay.GrahamScanDelaunay">GrahamScanDelaunay</a></code></h4>
<ul class="">
<li><code><a title="grahamscandelaunay.GrahamScanDelaunay.run" href="#grahamscandelaunay.GrahamScanDelaunay.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grahamscandelaunay.HalfEdge" href="#grahamscandelaunay.HalfEdge">HalfEdge</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>